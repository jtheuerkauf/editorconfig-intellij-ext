root = true

#
# Settings usage
# * Most settings have multiple levels: general and language-specific.
# * Order of priority: Language-specific > general > editor
# * If the editor doesn't have built-in support for a rule, settings in the file may have no effect.
# * Settings support a special "unset" value.
#   * If the winning (language vs. general) setting is "unset", the editor's setting (if supported) is always used.
#   * If the general setting is "unset" but the language has a value, that will be used - general will be ignored.
#

### ENUM VALUE GROUPS
### Explanation of value groups for various settings

## LEFT { PLACEMENT: end_of_line | gnu | next_line | next_line_if_wrapped | whitesmiths
#
## "end_of_line": Always place { at the end of the statement line
# class Foo {
#     private function foo() {
#         if (true) {
#
## "gnu": Always place { on next line (half-indent*)
#          * JetBrains IDEs alter this to a full indent, labeled "Next line, shifted".
#            The body of the statement aligns with the {
# class Foo
#   {               // GNU style
#      private function foo()
#          {        // Jetbrains version
#          if (true)
#            {      // GNU style
#
## "next_line": Always place { on next line (no indent)
# class Foo
# {
#     private function foo()
#     {
#         if (true)
#         {
#
## "next_line_if_wrapped": Place { on next line (no indent) only if the statement is wrapped
# class Foo {
#     private function foo(
#         param1,
#         param2,
#     )
#     {
#         if (true) {
#
## "whitesmiths": Place { on next line (full indent)
#                  The body is also indented
# class Foo
#     {
#         private function foo()
#             {
#                 if (true)
#                     {

## LINE WRAPS: normal | off | on_every_item | split_into_lines
#
## "off": Long lines are not wrapped during formatting. "ij_wrap_on_typing" is unaffected by this value.
#
## "normal": Break lines into continuation indents until the remaining text fits within max line length
##           In this example, the setting applies to extends/implements/permits keywords.
##           No consideration is given to context of keywords, lists, etc.
# -------------------------------| max-line-length
# class Anchovies extends BlueFinTuna implements Foo, Bar, FooFoo, BarBar {}
# // formatted:
# class Anchovies extends
#     BlueFinTuna implements Foo,
#     Bar, FooFoo, BarBar {}
#
## "on_every_item": Wrap the bound symbols into one-per-line regardless if the remainder is within max line limit.
##                  In this example, the setting applies to extends/implements/permits keywords:
##                  The keywords are "chopped" to the following lines, not the class names that follow.
# -------------------------------| max-line-length
# class Anchovies extends BlueFinTuna implements Foo, Bar, FooFoo, BarBar {}
# // formatted:
# class Anchovies extends
#     BlueFinTuna implements Foo, Bar,
#                FooFoo,
#                BarBar {}
#
## "split_into_lines": If any portion of the line exceeds the max limit, wrap the setting's target.
##                     Lists are further wrapped one-per-line.
##                     In this example, the setting applies to extends/implements/permits keywords:
##                     The classes following the keywords are wrapped, and the list is ...split into lines.
# -------------------------------| max-line-length
# class Anchovies extends BlueFinTuna implements Foo, Bar, FooFoo, BarBar {}
# // formatted:
# class Anchovies extends
#     BlueFinTuna implements
#     Foo,
#     Bar,
#     FooFoo,
#     BarBar {}
#

## ENFORCE CONTROL BLOCK { }: always | if_multiline | never
#
## "always": Braces are added to the control statement even if syntactically not required
# if (true) functionCall(); ~> if (true) {functionCall();}
#
# if (true)            ~>  if (true) {
#     functionCall();  ~>      functionCall();
#                      ~>  }
#
## "if_multiline": Braces are added to the control statement if the statement and body are on different lines
# if (true) functionCall(); ~> if (true) functionCall(); // unchanged
#
# if (true)            ~>  if (true) {
#     functionCall();  ~>      functionCall();
#                      ~>  }
#
## "never": Braces are not added
# if (true) functionCall(); ~> if (true) functionCall(); // unchanged
#
# if (true)            ~>  if (true)
#     functionCall();  ~>      functionCall();           // unchanged

#
# TODO In order to minimize duplicate setting explanations, prefer grouping by formatting category/grouping.
#      This allows settings from different languages to cluster together.
#      Only do language-specific grouping when no other language uses those settings.
#

[*]
########################
### STANDARD
###
# (ENUM) [latin1 | utf-8 | utf-16be | utf-16le]
charset = unset
# (ENUM) [cr | crlf | lf]
end_of_line = unset
# (STRING) tab: use width of a tab character (see tab_width)
# (INT > 0) tabs/spaces to use (see indent_style)
indent_size = tab
# (ENUM) [space | tab]
indent_style = unset
# (BOOL) ensure EOF is a single blank line
insert_final_newline = unset
# (STRING) off: do not hard-wrap long lines (or defer to editor)
# (INT > 0) length to hard-wrap lines
max_line_length = unset
# (INT > 0) visual representation of spaces a single tab character uses
tab_width = unset
# (BOOL) erase white space at the end of all lines
trim_trailing_whitespace = unset
###
########################

###########################
###                     ###
### INTELLIJ EXTENSIONS ###
###                     ###
###########################
# These will be reorganized as multi-language settings get grouped together

########################
### FORMATTER
###
# (BOOL) TODO: Determine functionality
ij_formatter_enabled = unset
# (BOOL) Should code formatting recognize blocks where formatting is turned off?
ij_formatter_tags_enabled = unset
# (STRING) String immediately after a comment leader to deactivate formatting (after the tag's placement)
# Ex: // @formatter:off
ij_formatter_off_tag = unset
# (STRING) String immediately after a comment leader to reactivate formatting (after the tag's placement)
# Ex: // @formatter:on
ij_formatter_on_tag = unset
###
########################

########################
### TABS / INDENTS
###
# (BOOL) preserve whitespace indents on blank lines to preserve context
# TODO: Does this override trim_tailing_whitespace?
ij_any_keep_indents_on_empty_lines = unset
# (INT > 0) to indent contiguous lines that are part of the same statement
# See indent_size, indent_style, tab_width for how this will be formatted
ij_continuation_indent_size = unset
# (BOOL) Minimize characters by mixing tab characters and spaces to reach indentation
ij_smart_tabs = unset
###
########################

########################
### SPACES
###
### Before [
### (BOOL) Ensure a space before the opening "[" of a block/structure
###

###
### Before {
### (BOOL) Ensure a space before the opening "{" of a block/structure
###
#
# true: " {1, 2, 3}"
# false: "{1, 2, 3}"
ij_any_space_before_array_initializer_left_brace = unset
# true: "catch {"
# false: "catch{"
ij_any_space_before_catch_left_brace = unset
# true: "class {"
# false: "class{"
ij_any_space_before_class_left_brace = unset
# true: "do {"
# false: "do{"
ij_any_space_before_do_left_brace = unset
# true: "else {"
# false: "else{"
ij_any_space_before_else_left_brace = unset
# true: "finally {"
# false: "finally{"
ij_any_space_before_finally_left_brace = unset
# true: "for () {"
# false: "for (){"
ij_any_space_before_for_left_brace = unset
# true: "if () {"
# false: "if (){"
ij_any_space_before_if_left_brace = unset
# true: "function () {"
# false: "function (){"
ij_any_space_before_method_left_brace = unset
# true: "switch () {"
# false: "switch (){"
ij_any_space_before_switch_left_brace = unset
# true: "try {"
# false: "try{"
ij_any_space_before_try_left_brace = unset
# true: "while () {"
# false: "while (){"
ij_any_space_before_while_left_brace = unset
###
### Before (
### (BOOL) Ensure a space before the opening "(" of a block/structure
###
# true: "catch ()"
# false: "catch()"
ij_any_space_before_catch_parentheses = unset
# true: "for ()"
# false: "for()"
ij_any_space_before_for_parentheses = unset
# true: "if ()"
# false: "if()"
ij_any_space_before_if_parentheses = unset
# true: "foo (bar)"
# false: "foo(bar)"
ij_any_space_before_method_call_parentheses = unset
# true: "function foo (param)"
# false: "function foo(param)"
ij_any_space_before_method_parentheses = unset
# true: "switch ()"
# false: "switch()"
ij_any_space_before_switch_parentheses = unset
# true: "while ()"
# false: "while()"
ij_any_space_before_while_parentheses = unset
###
### Before keywords
### (BOOL) Ensure a space before the opening "(" of a block/structure
###
# true: "while ()"
# false: "while()"
ij_any_space_before_catch_keyword = unset
# true: "while ()"
# false: "while()"
ij_any_space_before_else_keyword = unset
# true: "while ()"
# false: "while()"
ij_any_space_before_finally_keyword = unset
# true: "while ()"
# false: "while()"
ij_any_space_before_while_keyword = unset
###
### Around Operators
### (BOOL) Ensure a space before and after various operators
###
# true: "1 + 2", "3 - 1"
# false: "1+2", "3-1"
ij_any_spaces_around_additive_operators = unset
# true: "foo = 3"
# false: "foo=3"
ij_any_spaces_around_assignment_operators = unset
# true: "foo ^ 2", "foo | 2"
# false: "foo^2", "foo|2"
ij_any_spaces_around_bitwise_operators = unset
# true: "foo == 2", "foo != 2"
# false: "foo==2", "foo!=2"
ij_any_spaces_around_equality_operators = unset
# true: "foo && bar", "foo || bar"
# false: "foo&&bar", "foo||bar"
ij_any_spaces_around_logical_operators = unset
# true: "2 * 3", "6 / 3", "6 % 3"
# false: "2*3", "6/3", "6%3"
ij_any_spaces_around_multiplicative_operators = unset
# true: "2 < 3", "2 >= 3", "2 <=> 3"
# false: "2<3", "2>=3", "2<=>3"
ij_any_spaces_around_relational_operators = unset
# true: "foo << bar"
# false: "foo>>bar"
ij_any_spaces_around_shift_operators = unset
# true: "( ! foo)"
# false: "(!foo)"
ij_any_spaces_around_unary_operator = unset
###
### Within {} [] ()
### (BOOL) Ensure a space after left character and before right character
###
# true: "{ a, b, c }"
# false: "{a, b, c}"
ij_any_spaces_within_array_initializer_braces = unset
# true: "{ "foo":123 }"
# false: "{"foo":123}"
ij_any_spaces_within_braces = unset
# true: "[ 1, 2, 3 ]"
# false: "[1, 2, 3]"
ij_any_spaces_within_brackets = unset
# true: "catch ( Exception e )"
# false: "catch (Exception e)"
ij_any_spaces_within_catch_parentheses = unset
# true: "for ( a; b < c; b++ )"
# false: "for (a; b < c; b++)"
ij_any_spaces_within_for_parentheses = unset
# true: "if ( true )"
# false: "if (true)"
ij_any_spaces_within_if_parentheses = unset
# true: "foo( bar )"
# false: "foo(bar)"
ij_any_spaces_within_method_call_parentheses = unset
# true: "function foo( param )"
# false: "function foo( param )"
ij_any_spaces_within_method_parentheses = unset
# true: "A || ( B && C )"
# false: "A || (B&&C)"
ij_any_spaces_within_parentheses = unset
# true: "switch ( foo )"
# false: "switch (foo)"
ij_any_spaces_within_switch_parentheses = unset
# true: "while ( x < 5 )"
# false: "while (x < 5)"
ij_any_spaces_within_while_parentheses = unset
###
### In ternary ?:
### (BOOL) Define spaces around the "?" and ":" characters of a ternary expression
###
# true: "b ? c : d"
# false: "b? c : d"
ij_any_space_before_quest = unset
# true: "b ? c : d"
# false: "b ?c : d"
ij_any_space_after_quest = unset
# true: "b ? c : d"
# false: "b ? c: d"
ij_any_space_before_colon = unset
# true: "b ? c : d"
# false: "b ? c :d"
ij_any_space_after_colon = unset
###
### Other
### (BOOL) Placement of spaces in other scenarios
###
# true: "b , c ,d"
# false: "b, c,d"
ij_any_space_before_comma = unset
# true: "b, c , d"
# false: "b,c ,d"
ij_any_space_after_comma = unset
# true: "for (a = 1 ; a < b ;a++)"
# false: "for (a = 1; a < b;a++);"
ij_any_space_before_for_semicolon = unset
# true: "for (a = 1 ; a < b; a++)"
# false: "for (a = 1 ;a < b;a++);"
ij_any_space_after_for_semicolon = unset
# true: "(int) '1'"
# false: "(int)'1'"
ij_any_space_after_type_cast = unset
###
########################

########################
### WRAPPING / BRACES
###
# (INT > 0) Comma separated list of ascending values to set the right margin indicator
# Ex: 80
# Ex: 80, 120, 160
ij_visual_guides = unset
# (BOOL) Editor should actively break long lines while typing (see max_line_length)
ij_wrap_on_typing = unset
###
### Keep When Reformatting
###
# (BOOL) Preserve preexisting control statements that were formatted on one line
ij_any_keep_control_statement_in_one_line = unset
# (BOOL) Preserve preexisting comments places at start-of-line
ij_any_keep_first_column_comment = unset
# (BOOL) Preserve preexisting line breaks on unchanged lines
ij_any_keep_line_breaks = unset
# (BOOL) Preserve preexisting class definitions written on a single line
ij_any_keep_simple_blocks_in_one_line = unset
# (BOOL) Preserve preexisting class definitions written on a single line
ij_any_keep_simple_classes_in_one_line = unset
# (BOOL) Preserve preexisting function definitions written on a single line
ij_any_keep_simple_methods_in_one_line = unset
# (BOOL) Wrap long lines, formatting split lines according to other rules
ij_any_wrap_long_lines = unset
###
### Braces Placement
### (BLOCK BRACES ENUM) end_of_line | gnu | next_line | next_line_if_wrapped | whitesmiths
###
ij_any_block_brace_style = unset
ij_any_class_brace_style = unset
ij_any_lambda_brace_style = unset
ij_any_method_brace_style = unset
###
### Extends / Implements / Permits Lists
###
# (ENUM) [normal | off | on_every_item | split_into_lines]
# How to format classes applied by extends/implements/permits keywords when the line is wrapped
ij_any_extends_list_wrap = unset
# (BOOL) How to treat classes listed with the "extends", "implements", or "permits" keywords:
# true:  When classes wrap to multiple lines, align class names to each other
# false: Every line wraps to the previous line's indent, do not adjust class name alignment
ij_any_align_multiline_extends_list = unset
###
### Extends / Implements / Permits Keyword
###
# (ENUM) [normal | off | split_into_lines]*
# * "on_every_item" is supported, but is equivalent to "normal" because it applies to a single keyword, not a list.
ij_any_extends_keyword_wrap = unset
###
### Function Declaration Parameters
###
# (ENUM) [normal | off | on_every_item | split_into_lines]
# How to format function definition parameters when the line is wrapped
ij_any_method_parameters_wrap = unset
# (BOOL) Should function definition parameters be aligned when wrapped to multiple lines?
# true:  function foo(barA,
#                     barB) {}
# false: function foo(barA,
#            barB) {}
ij_any_align_multiline_parameters = unset
# (BOOL) When parameters are wrapped, add a line break after "("
# true:  function foo(
#            barA,
#            barB) {}
# false: function foo(barA,
#            barB) {}
ij_any_method_parameters_new_line_after_left_paren = unset
# (BOOL) When parameters are wrapped, add a line break before ")"
# true:  function foo(barA,
#            barB
#        ) {}
# false: function foo(barA,
#            barB) {}
ij_any_method_parameters_right_paren_on_new_line = unset
# (BOOL) TODO: TBD
ij_any_prefer_parameters_wrap = unset
###
### Function / Constructor Call Arguments
###
# (ENUM) [normal | off | on_every_item | split_into_lines]
# How to format function call arguments when the line is wrapped
ij_any_call_parameters_wrap = unset
# (BOOL) Should function call arguments be aligned when wrapped to multiple lines?
# true:  fooFunction(barA,
#                    barB);
# false: fooFunction(barA,
#            barB);
ij_any_align_multiline_parameters_in_calls = unset
# (BOOL) When arguments are wrapped, add a line break after "("
ij_any_call_parameters_new_line_after_left_paren = unset
# (BOOL) When parameters are wrapped, add a line break before ")"
ij_any_call_parameters_right_paren_on_new_line = unset
###
### Chained Method Calls
###
# (ENUM) [normal | off | on_every_item | split_into_lines]
# How to format function call chains when the line is wrapped
ij_any_method_call_chain_wrap = unset
# (BOOL) Should chained function calls be aligned when wrapped to multiple lines?
# true: align each call with the call on the preceding line
# Object.funcA()
#       .funcB()
# false: use continuation indent
# Object.funcA()
#     .funcB()
ij_any_align_multiline_chained_methods = unset
###
### 'if()' Statement
###
# (ENUM) [always | if_multiline | never]
ij_any_if_brace_force = unset
# (BOOL) true: wrap "else" to the line after "if" closing }
ij_any_else_on_new_line = unset
# (BOOL) If supported, should "else if" be unified as "elseif"?
ij_any_special_else_if_treatment = unset
###
### 'for()' / 'foreach()' Statement
###
# (ENUM) [always | if_multiline | never]
ij_any_for_brace_force = unset
# (ENUM) [normal | off | on_every_item | split_into_lines]
# How should the parts of a for()/foreach() statement be wrapped?
ij_any_for_statement_wrap = unset
# (BOOL) Should the parts of the for()/foreach() statement be aligned across lines?
# true:  for (index = 0;
#             index < count;
#             index++) {}
# false: for (index = 0;
#            index < count;
#            index++) {}
# true:  foreach ($fooBar as
#                 $foo => $bar) {}
# false: foreach ($fooBar as
#            $foo => $bar) {}
ij_any_align_multiline_for = unset
# (BOOL) When arguments are wrapped, add a line break after "("
ij_any_for_statement_new_line_after_left_paren = unset
# (BOOL) When parameters are wrapped, add a line break before ")"
ij_any_for_statement_right_paren_on_new_line = unset
###
### 'while()' Statement
###
# (ENUM) [always | if_multiline | never]
ij_any_while_brace_force = unset
###
### 'do...while()' Statement
###
# (ENUM) [always | if_multiline | never]
ij_any_do_while_brace_force = unset
# (BOOL) true: wrap "while" to the line after "do" closing }
ij_any_while_on_new_line = unset
###
### 'switch()' Statement
###
# (BOOL) true: "break" is indented; false: "break" is aligned with "case"
ij_any_indent_break_from_case = unset
# (BOOL) true: "case" is indented; false: "case" is aligned with "switch"
ij_any_indent_case_from_switch = unset
###
### 'try' Statement
###
# (BOOL) true: wrap "catch" to the line after "try"/"catch" closing }
ij_any_catch_on_new_line = unset
# (BOOL) true: wrap "finally" to the line after "try"/"catch" closing }
ij_any_finally_on_new_line = unset
###
### Binary Expressions
###
# (ENUM) [normal | off | on_every_item | split_into_lines]
ij_any_binary_operation_wrap = unset
# (BOOL) Should the operands in a multiline statement be aligned or set to continuation indent?
ij_any_align_multiline_binary_operation = unset
# (BOOL) Should the operator go to the next line with the operand or stay at end of previous line?
ij_any_binary_operation_sign_on_next_line = unset
# (BOOL) When an operand group gets wrapped, should a new line be forced after the opening "("?
ij_any_parentheses_expression_new_line_after_left_paren = unset
# (BOOL) When an operand group gets wrapped, should a new line be forced before the closing ")"?
ij_any_parentheses_expression_right_paren_on_new_line = unset
###
### Assignment Statement
###
# (ENUM) [normal | off | on_every_item | split_into_lines]
ij_any_assignment_wrap = unset
# (BOOL) Should the assignment operator move to lead the wrapped line or remain at end of line?
ij_any_place_assignment_sign_on_next_line = unset
###
### Class Property / Constant Groups
###
# (BOOL) Should groups of fields (on contiguous lines) be aligned on "="?
ij_any_align_group_field_declarations = unset
###
### Ternary Operation
###
# (ENUM) [normal | off | on_every_item | split_into_lines]
ij_any_ternary_operation_wrap = unset
# (BOOL) Should the true/false sides of the ternary be aligned when wrapped or set to continuation indent?
ij_any_align_multiline_ternary_operation = unset
# (BOOL) Should the "?" and ":" operators lead the wrapped line(s) or stay at end of previous line(s)?
ij_any_ternary_operation_signs_on_next_line = unset
###
### Array Initializer
###
# (ENUM) [normal | off | on_every_item | split_into_lines]
ij_any_array_initializer_wrap = unset
# (BOOL) Should the items in the array be aligned based on the first element?
ij_any_align_multiline_array_initializer_expression = unset
# (BOOL) Should a new line be forced after the opening "["?
ij_any_array_initializer_new_line_after_left_brace = unset
# (BOOL) Should a new line be forced before the closing "]"?
ij_any_array_initializer_right_brace_on_new_line = unset
###
### Modifier List
###
# (BOOL) Should wrapping include modifiers on class/properties/methods?
ij_any_modifier_list_wrap = unset
###
### Comments
###
###
########################

########################
### BLANK LINES
###
### Minimum Blank Lines
###
### (INT >= 0) Force minimum blank lines in these contexts
ij_any_blank_lines_after_class_header = unset
ij_any_blank_lines_after_imports = unset
ij_any_blank_lines_after_package = unset
ij_any_blank_lines_around_class = unset
ij_any_blank_lines_around_field = unset
ij_any_blank_lines_around_field_in_interface = unset
ij_any_blank_lines_around_method = unset
ij_any_blank_lines_around_method_in_interface = unset
ij_any_blank_lines_before_class_end = unset
ij_any_blank_lines_before_imports = unset
ij_any_blank_lines_before_method_body = unset
ij_any_blank_lines_before_package = unset
###
### Keep Maximum Blank Lines
###
### (INT >= 0) Limit blank lines in these contexts
ij_any_keep_blank_lines_before_right_brace = unset
ij_any_keep_blank_lines_in_code = unset
ij_any_keep_blank_lines_in_declarations = unset
###
########################

########################
### CODE GENERATION
###
### Comments
# (BOOL) Force a space before the start of text in a block comment
ij_any_block_comment_add_space = unset
# (BOOL) Move block comments to start-of-line instead of indented to context
ij_any_block_comment_at_first_column = unset
# (BOOL) Move line comments to start-of-line instead of indented to context
ij_any_line_comment_at_first_column = unset
# (BOOL) Force a space before the start of text when converting to a line comment
ij_any_line_comment_add_space = unset
# (BOOL) Force a space before the start of text when formatting
ij_any_line_comment_add_space_on_reformat = unset
###
########################

########################
### TBD
###
# (ENUM) [normal | off | on_every_item | split_into_lines]
ij_any_enum_constants_wrap = unset
# (BOOL) Should long lines in comments follow wrapping rules?
ij_any_wrap_comments = unset
###
########################

#############################
### PER-LANGUAGE SETTINGS ###
#############################

#########
## PHP ##
#########
########################
### PHP Doc
###
########################
